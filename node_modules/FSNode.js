/*用于存储目录结构的数据结构类*/

var util = require('util');
var path = require('path');
var url = require('url');
var fs = require('fs');
var EventEmitter = require("events").EventEmitter;

var FSNode = function(basePath){
	if(!basePath){
		throw new Error('basePath is necessary!');
	}
	this.basePath = path.normalize(basePath+path.sep);
	this._basePathExp = new RegExp('^'+this.basePath.replace(/\\/g,'\\\\'));
	this.tree = {}
	this.deletedPaths = [];
}
util.inherits(FSNode,EventEmitter);
FSNode.prototype._getRelativePath = function(p){
	if(!p){
		return p;
	}
	return path.normalize(p).replace(this._basePathExp,'');
}
/*添加路径，可为相对basePath的相对路径*/
FSNode.prototype.addPath = function(p,isFile){
	if(!p){
		return;
	}
	p = this._getRelativePath(p);
	var pathArr = p.split(path.sep);
	var fileName = isFile && pathArr.pop();
	var temp = pathArr.shift();
	var currentFSNode = this.tree;

	while(temp){
		currentFSNode = currentFSNode[temp] || (currentFSNode[temp] = {});
		temp = pathArr.shift();
	}
	if(fileName){
		currentFSNode[fileName] = 0;
	}
	var deleIndex = this.deletedPaths.indexOf(p);
	if(deleIndex > -1){
		this.deletedPaths.splice(deleIndex,1);//防止刚删除完就添加了
	}
	this.emit('addPath',p);
	return this;
}
/*删除路径*/
FSNode.prototype.deletePath = function(p){
	if(!p){
		return;
	}
	var _this = this;
	p = this._getRelativePath(p);
	var pathArr = p.split(path.sep);
	var temp = pathArr.shift();
	var currentFSNode = this.tree;
	var str = '';
	while(temp && (currentFSNode || currentFSNode == 0)){
		str += '["'+temp+'"]';
		currentFSNode = currentFSNode[temp];
		temp = pathArr.shift();
	}
	//这里保证了内存中的数据都是没有同步的
	if(!currentFSNode){
		this.deletedPaths.push(p);
	}
	(function(){
		var temp = this.tree;
		new Function('delete this.tree'+str).call(_this);
	})();
	this.emit('deletePath',p);
	return currentFSNode;
}
FSNode.prototype.toString = function(){
	return JSON.stringify(this.tree);
}
/*得到修改的文件结构,得到后会把内存数据清空*/
FSNode.prototype.getTree = function(){
	var tree = this.tree;
	this.tree = {};
	return tree;
}
/*得到优化完的要删除的文件或目录,得到后会把内存数据清空*/
FSNode.prototype.getDeleteTree = function(){
	var deletedPaths = this.deletedPaths;
	this.deletedPaths = [];
	var toDeleteStack = {};
	deletedPaths.sort(function(a,b){
		return a.length > b.length?1:-1;
	});
	var finalDeleteStack = [];
	var temp;
	while((temp = deletedPaths.shift())){
		var parentPath = path.dirname(temp);
		if(!toDeleteStack[parentPath]){
			finalDeleteStack.push(temp);
		}
		toDeleteStack[temp] = 1;
	}
	return finalDeleteStack;
}
module.exports = FSNode;