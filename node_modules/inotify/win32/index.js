var fs = require('fs'),
	path = require('path');
var log = require('utils/logger').log;
var CONST = require('../CONST');

var inotify = function(_path,fn_event){
	var files = {};
	var tt,delay = 1;
	var isDirStat = fs.statSync(_path).isDirectory();
	this.fsWatcher = fs.watch(_path, function (event, name) {
		clearTimeout(tt);
		tt = setTimeout(function (){
			var type = null;
			if(!isDirStat){
				type = name != null? CONST.EVENT_CHANGE: CONST.EVENT_REMOVE;
				isDir = false;
				var fullname = _path;
			}else if(name != null){// 对文件夹处理
				var fullname = path.join(_path, name);
				if(fs.existsSync(fullname)){
					var isDir = fs.statSync(fullname).isDirectory();
					if(event == 'rename'){
						type = CONST.EVENT_CREATE;
					}else if(event == 'change'){
						type = CONST.EVENT_CHANGE;
					}
				}
			}

			if(type){
				files[name] = isDir;
				fn_event(type,{
	            	fullname: fullname,
	            	filename: name,
	            	isDir: isDir
				});
				return;
			}
			var deleteFileName,isDir = false;
			if(fullname){
				deleteFileName = name;
				isDir = files[name];
			}else{
				var newFiles = fs.readdirSync(_path);
				for(var i in files){
					if(newFiles.indexOf(i) == -1){
						deleteFileName = i;
						isDir = files[i];
						break;
					}
				}
			}
			
			if(deleteFileName != null){
				delete files[deleteFileName];
				
				fn_event(CONST.EVENT_REMOVE,{
	            	fullname: path.join(_path,deleteFileName),
	            	filename: deleteFileName,
	            	isDir: isDir
				});
			}
		},delay);
	});
	this.fsWatcher.on('error',function(){
		// console.log(_path,arguments);
	});
	isDirStat && fs.readdir(_path,function(err,_files){
		if(!err){
			_files.forEach(function(file){
				var stat = fs.statSync(path.join(_path,file));
				files[file] = stat.isDirectory();
			});
		}
	});
}
inotify.prototype.remove = function(){
}

exports.inotify = inotify;